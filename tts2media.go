/*
Package tts2media runs TTS engines, converts their output to mp3 and ogg (as audio files)
and makes videos from images or other videos.

Files created by all functions and methods in this package are stored under the directory
passed to SetDataDir(), and read from a subdirectory, named "tmp", that must be
created under the same directory. If SetDataDir() isn't called, the media files will be saved
in the current working directory.

	saveDir, err := ioutil.TempDir(os.TempDir(), "")
	...
	err = os.Mkdir(saveDir+"tmp", 0700)
	...
	SetDataDir(saveDir)
	...
	espeak := &EspeakSpeech{
		Text:     "Hello World!",	// text to turn to speech
		Lang:     "en",			// language
		Speed:    "135",		// speed
		Gender:   "m",			// gender
		Altvoice: "0",			// alternative voice
		Quality:  "high",		// quality of output mp3/ogg audio
		Pitch:    "50",			// pitch
	}

	media, err := espeak.NewEspeakSpeech()
	...
	err = media.ToAudio()
	...
	media.RemoveWAV()

Other than RemoveWAV(), functions don't remove any files.

For the functions of this package that create videos, and unless specified otherwise,
the filenames passed should be the same as the input audio files, and should not
contain extensions.
*/
package tts2media

import (
	"bufio"
	"bytes"
	"encoding/binary"
	"errors"
	// "log"
	"math/rand"
	"net/http"
	"os"
	"os/exec"
	"strconv"
	"strings"
	"time"
)

// FilenameLen: length of the string returned as filename for media files (mp3, ogg, mp4, webm)
var FilenameLen int = 10

var (
	wavGenerated, audioGenerated, videoGenerated bool
	espeakData                                   string
	dataPath                                     string
	tempPath                                     string
)
var (
	espeakExe  = "espeak"
	picottsExe = "pico2wave"
	ffmpegExe  = "ffmpeg"
	ffprobeExe = "ffprobe"
)

// EspeakSpeech: values needed to create wav files by calling the Espeak speech engine
//
// Language: language of the speaker, aka "voice name" in espeak; values: "af", "bs", "ca", "cs",
// "cy", "de", "en", "en-sc", "en-uk", "en-uk-north", "en-uk-rp", "en-uk-wmids", "en-us", "en-wi",
// "eo", "es", "es-la", "fi", "fr", "fr-be", "grc", "hr", "hu", "id", "is", "it", "jbo", "ku",
// "la", "lv", "mk", "nl", "no", "pl", "pt-pt", "pt", "ro", "ru", "sk", "sq", "sr", "sv", "sw",
// "tr", "vi", "zh", "zh-yue", "hi", "el", "ta"
//
// Speed: speed in words per minute; values: from "80" to "390"
//
// Gender: gender of the speaker; values: "m" for male, and "f" for female. note: not all voices support different genders
//
// Altvoice: alternative voice; values: from "0" to "5"
//
// Quality: quality of the output MP3/OGG audio; values: "high", "medium" or "low"
//
// Pitch: pitch adjustment; values: from "0" to "99"
type EspeakSpeech struct {
	Text     string
	Lang     string
	Speed    string
	Gender   string
	Altvoice string
	Quality  string
	Pitch    string
}

// festivalSpeech: NOT IMPLEMENTED
// values needed to create wav files by calling the Festival speech engine
type festivalSpeech struct {
	Lang string
}

// PicoTTSSpeech: values needed to create wav files by calling the PicoTTS speech engine
type PicoTTSSpeech struct {
	Text    string
	Lang    string
	Quality string
}

// Media: values needed to create media (mp3, ogg, mp4, webm) files generated by the speech engines
type Media struct {
	Filename   string
	BitRate    string
	SampleRate string
}

// init checks that ffmpeg and the text-to-speech engines are installed in the system
func init() {
	exes := []string{espeakExe, picottsExe, ffmpegExe, ffprobeExe}
	for _, exe := range exes {
		_, err := exec.LookPath(exe)
		if err != nil {
			panic("the '" + exe + "' binary executable was not found")
		}
	}
}

// SetDataDir sets the directories where the media files are saved
func SetDataDir(dataDir string) {
	dataPath = dataDir
	tempPath = dataPath + "tmp/"
}

var (
	audioQuality = map[string][]string{
		// quality  ->  bitrate and sample rate passed to ffmpeg
		"low":    []string{"16k", "8000"},
		"high":   []string{"32k", "22050"},
		"medium": []string{"24k", "16000"},
	}

	espeakLangs = []string{
		// languages spoken by espeak, passed through the "-v" flag
		// to get a list, run: espeak --voices. note: mbrola voices are not listed here,
		// and, for some reason, they won't appear in the list shown by espeak.
		// these voices should be in the voices/mb/ directory in the espeak package.
		"af", "bs", "ca", "cs", "cy", "de", "en", "en-sc", "en-uk", "en-uk-north",
		"en-uk-rp", "en-uk-wmids", "en-us", "en-wi", "eo", "es", "es-la", "fi", "fr",
		"fr-be", "grc", "hr", "hu", "id", "is", "it", "jbo", "ku", "la", "lv", "mk", "nl",
		"no", "pl", "pt-pt", "pt", "ro", "ru", "sk", "sq", "sr", "sv", "sw", "tr", "vi",
		"zh", "zh-yue", "hi", "el", "ta",
	}

	// genders accepted by espeak, passed through the "-v" flag
	espeakGenders = []string{"m", "f"}
)

// to be used for bounds checking against integer arguments
type espeakArg struct {
	Name   string
	Limits []int
}

var espeakArgs = []espeakArg{
	// to be used for bounds checking against integer arguments
	// name of argument -> {min, max}
	{"speed", []int{80, 390}},
	{"altvoice", []int{0, 5}},
	{"pitch", []int{0, 99}},
}

// NewEspeakSpeech creates (after validating inputs) a WAV file with a random filename
// If the operation succeeds, it returns the filename (without path or extension)
// and a nil error. Otherwise, returns an empty string and an error
func (s *EspeakSpeech) NewEspeakSpeech() (*Media, error) {
	// this map is made only to be used in the next loop, to shorten code
	integerEspeakArgs := map[string]espeakArg{
		s.Speed:    espeakArgs[0],
		s.Altvoice: espeakArgs[1],
		s.Pitch:    espeakArgs[2],
	}

	// the idea here is: for every argument that is to be passed to espeak as integer type,
	// check that the string we received can be converted to int, and that this integer is
	// inside bounds. otherwise, return a non-nil error.
	for input, args := range integerEspeakArgs {
		if arg, err := strconv.Atoi(input); err != nil || arg < args.Limits[0] ||
			arg > args.Limits[1] {
			return nil, errors.New("error converting " + args.Name)
		}
	}

	// validate gender
	if !stringInSlice(s.Gender, espeakGenders) {
		return nil, errors.New("error converting gender")
	}

	// validate language
	if !stringInSlice(s.Lang, espeakLangs) {
		return nil, errors.New("error converting lang")
	}

	// validate quality, set bitrate and sample rate
	var bitRate, sampleRate string
	if val, ok := audioQuality[s.Quality]; ok {
		bitRate = val[0]
		sampleRate = val[1]
	} else {
		return nil, errors.New("wrong quality")
	}

	randName := randString(FilenameLen)

	variant := ""
	if s.Altvoice != "0" {
		variant = "+" + s.Gender + s.Altvoice
	}

	commandArgs := []string{"-w", dataPath + randName + ".wav", "-v",
		s.Lang + variant, "-s", s.Speed, "-p", s.Pitch}
	commandArgs = append(commandArgs, s.Text)

	if err := execCmd(espeakExe, commandArgs); err != nil {
		return nil, errors.New("error executing espeak, " + err.Error())
	}

	media := &Media{
		BitRate:    bitRate,
		SampleRate: sampleRate,
		Filename:   randName,
	}
	wavGenerated = true
	return media, nil
}

var picoTTSLangs = []string{"de-DE", "en-GB", "en-US", "es-ES", "fr-FR", "it-IT"}

// NewPicoTTSSpeech creates (after validating inputs) a WAV file with a random filename.
// If the operation succeeds, it returns the filename (without path or extension) and
// a nil error. Otherwise, returns an empty string and an error
func (s *PicoTTSSpeech) NewPicoTTSSpeech() (*Media, error) {

	// validate language
	if !stringInSlice(s.Lang, picoTTSLangs) {
		return nil, errors.New("error converting pitch")
	}

	// validate quality, set bitrate and sample rate
	var bitRate, sampleRate string
	if val, ok := audioQuality[s.Quality]; ok {
		bitRate = val[0]
		sampleRate = val[1]
	} else {
		return nil, errors.New("wrong quality")
	}

	randName := randString(FilenameLen)
	commandArgs := []string{"-w", dataPath + randName + ".wav", "-l", s.Lang, s.Text}

	if err := execCmd(picottsExe, commandArgs); err != nil {
		return nil, errors.New("error executing pico2wave, " + err.Error())
	}

	media := &Media{
		BitRate:    bitRate,
		SampleRate: sampleRate,
		Filename:   randName,
	}
	wavGenerated = true
	return media, nil
}

// NewFestivalSpeech NOT IMPLEMENTED
func (s *festivalSpeech) newFestivalSpeech() (*Media, error) {
	// NewFestivalSpeech creates a WAV file with a random filename.
	// If the operation succeeds, it returns the filename (without path or extension)
	// and a nil error. Otherwise, returns an empty string and an error
	// TODO
	return nil, errors.New("not implemented")
}

// RemoveWAV deletes the WAV file generated by the speech engines
func (m *Media) RemoveWAV() error {
	if err := os.Remove(dataPath + m.Filename + ".wav"); err != nil {
		return err
	}
	return nil
}

// ToAudio creates mp3 and ogg files from the wav file generated
// by NewEspeakSpeech, NewPicoTTSSpeech or NewFestivalSpeech
func (m *Media) ToAudio() error {
	var err error
	if wavGenerated != true {
		return errors.New("wav file has not been generated")
	}

	if m.Filename == "" {
		return errors.New("empty filename")
	}

	path := dataPath + m.Filename
	var commandArgs []string

	// -map_metadata ... removes all metadata
	// to remove metadata(?): "-map", "0:0", "-map_metadata", "-1",
	// to add echo, imitating a phone:  -af aecho=0.8:0.9:500:0.1
	commandArgs = []string{"-y", "-f", "wav", "-i", path + ".wav",
		"-ab", m.BitRate, "-ar", m.SampleRate, "-f", "mp3", path + ".mp3",
		"-ab", m.BitRate, "-ar", m.SampleRate, "-f", "ogg", path + ".ogg"}
	// }

	if err = execCmd(ffmpegExe, commandArgs); err != nil {
		return err
	}
	audioGenerated = true
	return nil
}

// execCmd executes the command passed through the commandArgs string slice, and returns an error
func execCmd(command string, commandArgs []string) error {

	var err error
	cmd := exec.Command(command, commandArgs...)

	// XXX uncomment if you want to see the command line being used
	// log.Println(command, commandArgs)

	// XXX uncomment if you want to see the output of the executable being run
	// cmd.Stderr = os.Stderr
	// cmd.Stdout = os.Stdout

	if err = cmd.Start(); err != nil {
		return err
	}

	if err = cmd.Wait(); err != nil {
		return err
	}
	return nil
}

// ImageToVideo creates Webm and MP4 files from the file specified as the first argument
// and the ogg file generated by ToAudio()
func (m *Media) ImageToVideo(imageExtension string) (string, error) {
	var filename string
	if audioGenerated != true {
		return "", errors.New("audio files have not been generated")
	}

	if m.Filename == "" {
		return "", errors.New("empty filename")
	}

	filename, err := ImageToVideo(m.Filename, imageExtension)
	if err != nil {
		return "", err
	}

	videoGenerated = true
	return filename, nil
}

// FromVideo creates videos from inputs video and Ogg audio files (previously generated by ToAudio).
// The last argument indicates the length, in seconds, of the output file: if lengthAsVideo is true,
// the length of the output file, in seconds, is the same as the input video.
// Otherwise, it is the same as the input audio.
// The output videos are stored with the same format (plus corresponding extensions) as input files.
// FromVideo checks if the (OGG) audio file exists, and detects the mime type of the input video.
func FromVideo(Audio string, lengthAsVideo bool) (string, error) {
	if Audio == "" || len(Audio) != FilenameLen {
		return "", errors.New("empty or wrong filename")
	}
	var err error
	var duration, input, mime string
	var commandArgs []string

	filename := randString(FilenameLen)
	inAudio := dataPath + Audio
	outpath := dataPath + filename

	if _, err = os.Stat(inAudio + ".ogg"); err != nil {
		return "", err
	}

	input = tempPath + Audio

	// TODO change aac to libfdk_aac
	if lengthAsVideo {
		if duration, err = Duration(input); err != nil {
			return "", err
		}
	} else {
		if duration, err = Duration(inAudio + ".ogg"); err != nil {
			return "", err
		}
	}

	if mime, err = Type(tempPath + Audio); err != nil {
		return "", err
	}
	isVideo := strings.HasPrefix(mime, "video")
	isMp4 := strings.HasSuffix(mime, "mp4")
	isWebm := strings.HasSuffix(mime, "webm")

	if !isVideo || !(isMp4 || isWebm) {
		return "", errors.New("Invalid file format/ MIME type")
	}

	// https://stackoverflow.com/questions/13041061/
	// https://stackoverflow.com/questions/12938581/12943003#12943003
	switch mime {
	case "video/mp4":
		if lengthAsVideo {
			commandArgs = []string{"-y", "-t", duration, "-i", input, "-i",
				inAudio + ".ogg", "-c:v", "copy", "-c:a", "aac", "-strict",
				"experimental", "-map", "0:0", "-map", "1:0", "-f", "mp4",
				"-shortest", outpath + ".mp4"}
		} else {
			commandArgs = []string{"-y", "-i", input, "-i", inAudio + ".ogg",
				"-c:v", "copy", "-c:a", "aac", "-strict", "experimental", "-map",
				"0:0", "-map", "1:0", "-f", "mp4", "-t", duration, outpath + ".mp4"}
		}
	case "video/webm":
		if lengthAsVideo {
			commandArgs = []string{"-y", "-t", duration, "-i", input, "-i",
				inAudio + ".ogg", "-c:v", "copy", "-c:a", "copy", "-map", "0:0",
				"-map", "1:0", "-f", "webm", "-shortest", outpath + ".webm"}
		} else {
			commandArgs = []string{"-y", "-i", input, "-i", inAudio + ".ogg",
				"-c:v", "copy", "-c:a", "copy", "-map", "0:0", "-map", "1:0",
				"-f", "webm", "-t", duration, outpath + ".webm"}
		}
	default:
		return "", errors.New("Invalid file format/ MIME type")
	}

	if err = execCmd(ffmpegExe, commandArgs); err != nil {
		return "", err
	}

	videoGenerated = true
	return filename, nil
}

// ImageToVideo creates two videos, encoded as MP4 and Webm, from the input files.
// Inputs are: an image file and an OGG audio file (previously generated by ToAudio).
// The filename of the input images should include the file extension.
// The output video is stored in dataPath, with formats (= extensions) webm and mp4.
// ImageToVideo checks if the (OGG) audio file exists.
func ImageToVideo(Audio, imageExtension string) (string, error) {
	var err error
	if Audio == "" || len(Audio) != FilenameLen {
		return "", errors.New("empty or wrong filename")
	}

	filename := randString(FilenameLen)
	inAudio := dataPath + Audio
	outpath := dataPath + filename
	frameRate := "2/3"

	if _, err = os.Stat(inAudio + ".ogg"); err != nil {
		return "", err
	}

	var commandArgs []string

	commandArgs = []string{"-y", "-loop", "1", "-r", frameRate, "-i",
		tempPath + Audio + "." + imageExtension, "-i", inAudio + ".ogg",
		"-c:v", "libvpx", "-b:v", "0", "-crf", "34" /* "20" ?*/, "-c:a", "copy",
		"-shortest", "-tune", "stillimage", "-f", "webm", outpath + ".webm"}

	if err = execCmd(ffmpegExe, commandArgs); err != nil {
		return "", err
	}

	var duration string
	if duration, err = Duration(inAudio + ".ogg"); err != nil {
		return "", err
	}

	// TODO change aac to libfdk_aac
	// FIXME ffmpeg has a bug: the duration of mp4 videos made from image + audio is longer than
	// the length of the audio; solution: read the Duration of the input audio file and use
	// "-t", inputLength (eg: 0:0:58.27 ), bug report:  https://trac.ffmpeg.org/ticket/5033
	commandArgs = []string{"-y", "-loop", "1", "-r", frameRate, "-i", tempPath + Audio + "." +
		imageExtension, "-i", inAudio + ".ogg", "-c:v", "libx264", "-preset", "veryfast",
		// "-qscale:v", "4", "-profile:v", "baseline"
		"-crf", "28", "-tune", "stillimage", "-vf", `scale=trunc(iw/2)*2:trunc(ih/2)*2`,
		"-c:a", "aac", "-ab", "24k", "-strict", "experimental", "-shortest", "-pix_fmt",
		"yuv420p", "-movflags", "faststart", "-f", "mp4", "-t", duration, outpath + ".mp4"}

	if err = execCmd(ffmpegExe, commandArgs); err != nil {
		return "", err
	}

	return filename, nil
}

// Duration returns the "Duration" from the format info
func Duration(path string) (string, error) {
	out, err := exec.Command(ffprobeExe, "-i", path, "-show_entries", "format=duration",
		"-v", "quiet", "-of", "csv=p=0").Output()
	if err != nil {
		return "", err
	}
	i := bytes.IndexByte(out, '.')
	a, err := strconv.ParseUint(string(out[:i]), 10, 64)
	if err != nil {
		return "", err
	}
	return strconv.FormatUint(uint64(a+1), 10), nil
}

// Function Type returns the MIME type of the media files, or an error if the file is not
// a jpg, gif, png, mp3, ogg, webm or mp4 file
func Type(path string) (string, error) {

	var (
		contentType string
		err         error
	)

	var file *os.File
	if file, err = os.Open(path); err != nil {
		return "", errors.New("Error opening file: " + err.Error())
	}
	defer file.Close()

	rFile := bufio.NewReader(file)
	rBytes, err := rFile.Peek(512)
	if err != nil {
		return "", errors.New("Error reading file" + err.Error())
	}

	if contentType = match(rBytes); contentType == "" {
		contentType = http.DetectContentType(rBytes)
	}

	return contentType, nil
}

// TODO remove match() when using Go 1.5.2, after checking that the patch has been merged:
// https://github.com/golang/go/commit/8b1152a599ea6d5f0515bcec3c5131445cc87f5c
var mp4ftype = []byte("ftyp")
var mp4 = []byte("mp4")

func match(data []byte) string {
	if len(data) < 12 {
		return ""
	}

	boxSize := int(binary.BigEndian.Uint32(data[:4]))
	if boxSize%4 != 0 || len(data) < boxSize {
		return ""
	}
	if !bytes.Equal(data[4:8], mp4ftype) {
		return ""
	}
	for st := 8; st < boxSize; st += 4 {
		if st == 12 {
			continue
		}
		if bytes.Equal(data[st:st+3], mp4) {
			return "video/mp4"
		}
	}
	return ""
}

// https://stackoverflow.com/a/31832326
const letterBytes = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
const (
	letterIdxBits = 6                    // 6 bits to represent a letter index
	letterIdxMask = 1<<letterIdxBits - 1 // All 1-bits, as many as letterIdxBits
	letterIdxMax  = 63 / letterIdxBits
)

var src = rand.NewSource(time.Now().UnixNano())

func randString(n int) string {
	b := make([]byte, n)
	// A src.Int63() generates 63 random bits, enough for letterIdxMax characters!
	for i, cache, remain := n-1, src.Int63(), letterIdxMax; i >= 0; {
		if remain == 0 {
			cache, remain = src.Int63(), letterIdxMax
		}
		if idx := int(cache & letterIdxMask); idx < len(letterBytes) {
			b[i] = letterBytes[idx]
			i--
		}
		cache >>= letterIdxBits
		remain--
	}

	return string(b)
}

func stringInSlice(a string, list []string) bool {
	for _, b := range list {
		if b == a {
			return true
		}
	}
	return false
}
